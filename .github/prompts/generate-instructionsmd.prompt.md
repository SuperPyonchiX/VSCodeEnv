---
description: 'リポジトリ用の高品質なインストラクションファイルを生成するプロンプト'
mode: 'agent'
---

# 高品質なインストラクションファイルの作成

あなたはコードエージェントです。あなたのタスクは、https://code.visualstudio.com/docs/copilot/customization/custom-instructions の公式ガイダンスに従って、このリポジトリに完全で正確なカスタムインストラクションファイルを作成することです。

## インストラクションファイルとは?

カスタムインストラクションファイルは、GitHub Copilotがドメイン固有のコードを生成し、プロジェクトの規約に従うための、効果的で保守可能なガイダンスを提供するMarkdownファイルです。これらのファイルは、コード生成、レビュー、ドキュメント作成のためのコンテキストに応じた指示を提供します。

## 重要原則

- **コンテキスト重視**: 特定のファイルタイプやディレクトリに適用される詳細な技術的指示を含む
- **実行可能性**: 具体的で実行可能なガイドラインを提供、曖昧な指示を避ける
- **標準化された場所**: `.github/instructions/` ディレクトリに配置
- **Globパターン**: `applyTo` フィールドで適用範囲を明確に定義
- **バージョン管理**: コードとともに進化する生きたドキュメント

## 必須フロントマター

すべてのインストラクションファイルには、以下のYAMLフロントマターが必要です:

```yaml
---
description: 'インストラクションの目的と範囲の簡単な説明'
applyTo: 'ターゲットファイルのglobパターン (例: **/*.ts, **/*.py)'
---
```

### フロントマターガイドライン

- **description**: シングルクォートで囲まれた1〜500文字の文字列、目的を明確に記述
- **applyTo**: これらのインストラクションが適用されるファイルを指定するglobパターン
  - 単一パターン: `'**/*.ts'`
  - 複数パターン: `'**/*.ts, **/*.tsx, **/*.js'`
  - 特定ディレクトリ: `'src/**/*.py'`
  - すべてのファイル: `'**'`

## ファイル命名規則

- `.instructions.md` 拡張子を使用
- ケバブケース（ハイフン区切りの小文字）を使用
- 内容を説明的に表現
- 例: `react-best-practices.instructions.md`, `python-security.instructions.md`, `typescript-conventions.instructions.md`

## ファイル構造

### 1. タイトルと概要

```markdown
# 技術名 開発ガイド

これらのインストラクションの目的と範囲を説明する簡単な導入文。

## プロジェクトコンテキスト

- 対象読者: 開発者とGitHub Copilot
- 技術: 主要な技術とバージョンをリスト
- 目的: これらのインストラクションが支援する内容
```

### 2. 一般的な指示

高レベルのガイドラインと原則:

```markdown
## 一般的な指示

- 高レベルガイドライン 1
- 高レベルガイドライン 2
- 一般原則 3
```

### 3. ベストプラクティス

推奨されるパターンとアプローチ:

```markdown
## ベストプラクティス

- 具体的なプラクティス 1 と理由
- 具体的なプラクティス 2 と理由
- 推奨アプローチ 3 と例
```

### 4. コード標準

命名規則、フォーマット、スタイルルール:

```markdown
## コード標準

### 命名規則
- 変数: ローカル変数には `camelCase` を使用
- 関数: 関数名には `camelCase` を使用
- クラス: クラス名には `PascalCase` を使用
- 定数: 定数には `UPPER_SNAKE_CASE` を使用

### ファイル構成
- ファイルごとに1つのコンポーネント
- 関連ファイルをディレクトリにグループ化
- モジュールエクスポートにはindexファイルを使用

### インポート順序
1. 外部依存関係
2. 内部モジュール
3. 相対インポート
4. 型とインターフェース
```

### 5. 一般的なパターン

頻繁に使用される実装パターン:

```markdown
## 一般的なパターン

### パターン 1: エラーハンドリング
このパターンをいつ、なぜ使用するかの説明。

\`\`\`language
// 良い例
try {
  await performOperation();
} catch (error) {
  logger.error('操作が失敗しました', { error });
  throw new CustomError('操作の実行に失敗しました', error);
}
\`\`\`

### パターン 2: 非同期操作
説明と例。
```

### 6. セキュリティ考慮事項（該当する場合）

```markdown
## セキュリティ

- 処理前に必ずユーザー入力を検証する
- SQLインジェクションを防ぐためにパラメータ化されたクエリを使用
- シークレットは環境変数に保存し、コードには決して含めない
- 適切な認証と認可を実装
- 本番環境のすべてのエンドポイントでHTTPSを有効化
```

### 7. パフォーマンス最適化（該当する場合）

```markdown
## パフォーマンス

- 高コストな計算をキャッシュ
- 大規模データセットには遅延読み込みを使用
- リストエンドポイントにページネーションを実装
- 適切なインデックスでデータベースクエリを最適化
- データベース接続にコネクションプーリングを使用
```

### 8. テスト基準（該当する場合）

```markdown
## テスト

### ユニットテスト
- 各関数を独立してテスト
- 外部依存関係にはモックを使用
- 80%以上のコードカバレッジを目指す

### 統合テスト
- APIエンドポイントをエンドツーエンドでテスト
- データベース操作を検証
- エラーシナリオをテスト

### テスト構成
- テストはソースファイルの隣に配置: `component.ts` → `component.test.ts`
- 説明的なテスト名を使用: `describe('UserService')` → `it('有効なデータでユーザーを作成する')`
```

## 例とコードスニペット

良い例と悪い例を明確に示す:

```markdown
### 良い例 - 型安全性
\`\`\`typescript
interface User {
  id: string;
  name: string;
  email: string;
}

function getUser(id: string): Promise<User> {
  return userRepository.findById(id);
}
\`\`\`

### 悪い例 - any型の使用
\`\`\`typescript
function getUser(id: any): any {
  // 型安全性が失われる
  return userRepository.findById(id);
}
\`\`\`
```

## 検証と確認

プロジェクトで使用されている実際のコマンドを含める:

```markdown
## 検証

- **ビルド**: `npm run build` - コンパイルエラーがないことを確認
- **リンティング**: `npm run lint` - コードスタイルが規約に従っていることを確認
- **フォーマット**: `npm run format` - 一貫したフォーマットを適用
- **型チェック**: `npm run type-check` - TypeScriptの型エラーをチェック
- **テスト**: `npm test` - すべてのテストが合格することを確認
```

## よくあるパターンとテーブルの使用

構造化された情報にはテーブルを使用:

```markdown
## よくある問題と解決策

| 問題               | 解決策                   | 例                                |
| ------------------ | ------------------------ | --------------------------------- |
| マジックナンバー   | 名前付き定数を使用       | `const MAX_RETRIES = 3`           |
| 深いネスト         | 関数を抽出               | ネストされたif文をリファクタリング |
| ハードコードされた値 | 設定を使用               | API URLを設定に保存               |
```

## 条件付きガイダンス

異なるシナリオに応じた指示:

```markdown
## フレームワークの選択

- **小規模プロジェクトの場合**: Minimal APIアプローチを使用
- **大規模プロジェクトの場合**: 明確な分離を持つコントローラーベースのアーキテクチャを使用
- **マイクロサービスの場合**: ドメイン駆動設計パターンを検討
```

## 避けるべきパターン

インストラクションファイルを作成する際は、以下を避けてください:

- **過度に冗長な説明**: 簡潔でスキャン可能に保つ
- **古い情報**: 常に現在のバージョンとプラクティスを参照
- **曖昧なガイドライン**: 何をするか、または避けるべきかを具体的に記述
- **例の欠如**: 具体的なコード例のない抽象的なルール
- **矛盾したアドバイス**: ファイル全体で一貫性を確保
- **ドキュメントからのコピー＆ペースト**: 要約とコンテキスト化による価値を追加

## テンプレート例

基本的なインストラクションファイルのテンプレート:

```markdown
---
description: '目的の簡単な説明'
applyTo: '**/*.ext'
---

# 技術名 開発ガイド

これらのインストラクションについての簡単な導入とコンテキスト。

## 一般的な指示

- 高レベルガイドライン 1
- 高レベルガイドライン 2
- 一般原則 3

## ベストプラクティス

### プラクティスカテゴリ 1
- 理由を含む具体的なプラクティス
- 例を含む別のプラクティス

### プラクティスカテゴリ 2
- プラクティスの説明
- 実装の詳細

## コード標準

### 命名規則
- 変数: `命名スタイル`
- 関数: `命名スタイル`
- クラス: `命名スタイル`

### ファイル構成
- 構造ルール 1
- 構造ルール 2

### インポート順序
1. インポートタイプ 1
2. インポートタイプ 2
3. インポートタイプ 3

## 一般的なパターン

### パターン 1: パターン名
このパターンをいつ、なぜ使用するかの説明。

\`\`\`language
// 良い例
コードをここに
\`\`\`

\`\`\`language
// 悪い例 - これを避ける
コードをここに
\`\`\`

### パターン 2: 別のパターン
説明と例。

## セキュリティ考慮事項

- セキュリティガイドライン 1
- セキュリティガイドライン 2
- セキュリティベストプラクティス 3

## パフォーマンスガイドライン

- パフォーマンスのヒント 1
- パフォーマンスのヒント 2
- 最適化戦略 3

## テスト標準

### ユニットテスト
- テストガイドライン 1
- テストガイドライン 2

### 統合テスト
- 統合テストアプローチ
- カバレッジ要件

## 検証

- ビルド: `検証コマンド`
- リンティング: `リントコマンド`
- フォーマット: `フォーマットコマンド`
- テスト: `テストコマンド`
```

## 実装ステップ

1. **プロジェクトを分析**:
   - 使用されているプログラミング言語とフレームワークを特定
   - 既存のコーディング規約とパターンを調査
   - プロジェクト構造と組織を理解
   - package.json、Makefile、設定ファイルを確認

2. **対象範囲を決定**:
   - インストラクションが適用されるファイルタイプを特定
   - 適切なglobパターンを定義
   - 複数のファイルタイプが必要か判断

3. **既存の規約を収集**:
   - プロジェクト固有のパターンを探す
   - 一般的なコード構造を確認
   - チーム固有のベストプラクティスを特定
   - 既存のドキュメントやスタイルガイドを参照

4. **セクションを構造化**:
   - 論理的な順序でセクションを整理
   - 最も重要な情報を先に配置
   - 関連する概念をグループ化
   - 読みやすさのために見出しを使用

5. **具体的な例を提供**:
   - 良い例と悪い例の両方を含める
   - 実際のプロジェクトコードに基づいた例を使用
   - コードスニペットが正しく実行可能であることを確認
   - 適切な構文ハイライトを使用

6. **検証手順を追加**:
   - 実際に使用されているビルドコマンドを含める
   - リンティングとフォーマットツールを文書化
   - テストコマンドと要件を指定
   - 品質チェック手順を説明

7. **レビューとテスト**:
   - Copilotでインストラクションをテスト
   - コード例が正しいことを確認
   - Globパターンが意図したファイルと一致することを確認
   - チームメンバーからフィードバックを収集

## ベストプラクティス

- **具体的に記述**: 抽象的な概念ではなく具体的な例を提供
- **理由を示す**: 価値を追加する場合は、推奨事項の背後にある理由を説明
- **最新の情報を保つ**: 現在のバージョンとベストプラクティスを参照
- **テーブルを活用**: オプションの比較、ルールのリスト、パターンの表示に使用
- **コードスニペットを含める**: 説明よりも実際のコード例の方が効果的
- **リソースをリンク**: 公式ドキュメントと権威あるソースを含める
- **一貫性を保つ**: ファイル全体で用語とスタイルを統一
- **スキャン可能に**: 箇条書き、見出し、テーブルで情報を構造化

## メンテナンス

- 依存関係やフレームワークが更新されたら、インストラクションをレビュー
- 現在のベストプラクティスを反映するように例を更新
- 古いパターンや非推奨の機能を削除
- コミュニティで新しいパターンが出現したら追加
- プロジェクト構造の変更に応じてglobパターンを正確に保つ

## 最終注記

インストラクションファイルは、GitHub Copilotがプロジェクトのコーディング規約、パターン、ベストプラクティスを理解するのを支援する生きたドキュメントです。これらのファイルは具体的で、実行可能で、最新の状態に保たれるべきです。目標は、Copilotが人間のガイダンスを最小限に抑えて、プロジェクトの標準に従ったコードを生成できるようにすることです。

## 参考資料

- **Custom Instructions Documentation**: https://code.visualstudio.com/docs/copilot/customization/custom-instructions
- **Awesome Copilot Instructions**: https://github.com/github/awesome-copilot/tree/main/instructions
- **VS Code Copilot Documentation**: https://code.visualstudio.com/docs/copilot/overview

## タスク完了基準

インストラクションファイルを作成する際は、明確さ、完全性、実行可能性を優先します。目標は、GitHub Copilotに、追加の人間のガイダンスを必要とせずにプロジェクトの規約に従ったコードを生成するのに十分なコンテキストを提供することです。

完了前に以下を確認してください:
- [ ] YAMLフロントマターが適切に設定されている
- [ ] `applyTo` globパターンが正しいファイルをターゲットにしている
- [ ] すべてのセクションが論理的に整理されている
- [ ] 良い例と悪い例の両方が含まれている
- [ ] 検証コマンドがプロジェクトで実際に使用されている
- [ ] コードスニペットが正しく実行可能である
- [ ] ファイル名がケバブケースで説明的である
- [ ] 内容が簡潔でスキャン可能である
