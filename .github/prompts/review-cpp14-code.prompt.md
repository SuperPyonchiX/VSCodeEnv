---
description: 'AUTOSAR C++14およびCERT C++準拠のコードレビューを実行'
agent: 'review-cpp14-code'
tools: ['vscode', 'read', 'edit', 'search']
---

# C++14コードレビュー実行

AUTOSAR C++14とCERT C++のコーディング規約に準拠したC++14コードの包括的なレビューを実行します。

## 📥 必須入力

- `${input:targetFiles}`: レビュー対象のファイルまたはディレクトリパス
- `${input:reviewFocus}`: レビュー重点項目（オプション: security/performance/maintainability/all）
- `${input:gitCommitHash}`: 比較元のGitコミットハッシュ（オプション: 指定時は差分のみレビュー）

## 📋 実行ステップ

### ステップ 1: コード収集と分析準備
1. **Git差分の取得（オプション）**
   - `${input:gitCommitHash}` が指定されている場合:
     - `git diff ${input:gitCommitHash}..HEAD` で変更ファイル一覧を取得
     - 変更された行のみを特定（追加・修正・削除）
     - C++ソースファイル(.cpp, .h, .hpp)の変更に絞り込み
     - 各ファイルの変更箇所（行番号範囲）を記録
   - 指定されていない場合:
     - `${input:targetFiles}` の全体をレビュー対象とする

2. **対象ファイルの特定**
   - Git差分または `${input:targetFiles}` からC++ソースファイルを収集
   - ファイル構造とモジュール構成を把握
   - レビュー範囲を明確化（差分のみ or ファイル全体）

3. **規約ドキュメント参照準備**
   - AUTOSAR C++14規約の主要ルールをロード
   - CERT C++セキュアコーディング規約を参照
   - プロジェクト固有のコーディング規約があれば統合

### ステップ 2: AUTOSAR C++14準拠チェック
1. **必須ルール(Required Rules)のチェック**
   - A0-1-1: プロジェクトの適切なドキュメント化
   - A2-7-1: すべての関数は戻り値の型を持つべき
   - A3-1-1: constポインタやconst参照の適切な使用
   - A5-0-2: 配列からポインタへの暗黙的な変換を避ける
   - A7-1-1: 変数の初期化は宣言時に実施
   - A8-4-1: 関数のパラメータは値渡し、const参照、ポインタのいずれか
   - A10-3-1: 仮想関数はvirtualまたはoverride指定子を持つべき
   - A12-8-1: コピーおよびムーブコンストラクタは正しく実装
   - A15-1-1: 例外処理の適切な使用

2. **アドバイザリールール(Advisory Rules)のチェック**
   - A0-1-2: 未使用コードの検出
   - A2-10-1: 識別子の適切な命名規則
   - A4-7-1: 整数型の適切な使用
   - A5-1-1: リテラル値の適切な型指定
   - A7-1-4: 非const参照の適切な使用

3. **特定ドメインルールのチェック**
   - メモリ管理: 動的メモリ割り当ての使用制限
   - 型安全性: 暗黙的な型変換の回避
   - スレッド安全性: 共有リソースへのアクセス制御

### ステップ 3: CERT C++準拠チェック
1. **宣言と初期化(DCL)**
   - DCL50-CPP: グローバル名前空間を汚染しない
   - DCL51-CPP: 配列型をポインタ型として宣言しない
   - DCL53-CPP: 型の前方宣言を避ける
   - DCL54-CPP: 関数の過剰なオーバーロードを避ける

2. **式(EXP)**
   - EXP50-CPP: C++標準ライブラリコンテナのループ変数を変更しない
   - EXP51-CPP: 副作用のある式の評価順序に依存しない
   - EXP53-CPP: 配列の範囲外アクセスを行わない
   - EXP55-CPP: ポインタ演算で配列境界を超えない

3. **整数(INT)**
   - INT50-CPP: 整数型のオーバーフローを回避
   - INT51-CPP: 符号なし整数のラップアラウンドに注意

4. **メモリ管理(MEM)**
   - MEM50-CPP: 解放後のメモリにアクセスしない
   - MEM51-CPP: 適切にメモリを解放する
   - MEM52-CPP: 所有権が曖昧なメモリを検出
   - MEM53-CPP: メモリ割り当ての失敗をチェック
   - MEM54-CPP: placement newの適切な使用
   - MEM55-CPP: 不適切なメモリアライメントを避ける

5. **オブジェクト指向プログラミング(OOP)**
   - OOP50-CPP: delete操作前にオブジェクトを適切な型にキャスト
   - OOP51-CPP: リソースを管理するクラスでコピー代入演算子を実装
   - OOP52-CPP: 仮想デストラクタを持つ基底クラスを設計
   - OOP53-CPP: メンバ関数をconstで修飾できる場合は修飾
   - OOP54-CPP: 代入演算子の適切な実装
   - OOP55-CPP: pure virtual関数を呼び出さない
   - OOP56-CPP: 仮想関数の名前は再利用しない
   - OOP57-CPP: 基底クラスの関数を隠蔽しない
   - OOP58-CPP: コピー操作はコピー可能な部分をコピー

6. **エラー処理(ERR)**
   - ERR50-CPP: 例外をvalue、参照でキャッチしない
   - ERR51-CPP: 例外処理中に例外をスローしない
   - ERR52-CPP: デストラクタから例外をスローしない
   - ERR53-CPP: noexcept関数から例外をスローしない
   - ERR54-CPP: すべての例外をキャッチしない
   - ERR55-CPP: 例外処理前提のコードで適切にエラーハンドリング
   - ERR56-CPP: 例外仕様は保証する
   - ERR57-CPP: std::exception階層の例外のみスロー
   - ERR58-CPP: コンストラクタからの例外を適切に処理
   - ERR59-CPP: 例外安全性を保証
   - ERR60-CPP: 例外ハンドラの順序に注意
   - ERR61-CPP: 例外オブジェクトをcatch byリファレンスでキャッチ
   - ERR62-CPP: setjmp/longjmpをC++で使用しない

7. **コンテナ(CTR)**
   - CTR50-CPP: const適用が不適切なコンテナメンバ関数の使用を保証
   - CTR51-CPP: 変更不可能なコンテナ要素の修正を試みない
   - CTR52-CPP: イテレータの無効化を保証
   - CTR53-CPP: コンテナの範囲外アクセスを避ける
   - CTR54-CPP: エラー後のコンテナ状態に依存しない
   - CTR55-CPP: 削除されたイテレータへのアクセスを避ける
   - CTR56-CPP: ポインタをランダムアクセスイテレータとして使用しない
   - CTR57-CPP: コンテナ比較でカスタム比較演算子を提供
   - CTR58-CPP: 述語関数のオブジェクトはコピー可能に設計

8. **入力/出力(FIO)**
   - FIO50-CPP: ファイルを閉じる際の失敗をチェック
   - FIO51-CPP: ファイルストリームのエラー状態を適切に処理

### ステップ 4: コード品質分析
1. **保守性の評価**
   - コードの複雑度（循環的複雑度）
   - 関数/メソッドの長さ
   - クラスの責務の明確性
   - 命名規約の一貫性

2. **パフォーマンス考慮事項**
   - 不要なコピー操作の検出
   - move semanticsの活用機会
   - const correctnessの徹底
   - インライン化の適切な使用

3. **セキュリティ脆弱性**
   - バッファオーバーフロー
   - NULL/未初期化ポインタの使用
   - メモリリーク
   - データ競合の可能性

### ステップ 5: レビューレポート作成
1. **違反項目の整理**
   - 重大度別（Critical/High/Medium/Low）に分類
   - AUTOSAR/CERT規約の具体的なルール番号を記載
   - 該当コードの行番号とスニペット

2. **修正提案の作成**
   - 各違反項目に対する具体的な修正方法
   - ベストプラクティスに基づく推奨実装
   - サンプルコードの提供

3. **サマリー作成**
   - レビュー対象ファイル数と総行数
   - 検出された問題の総数と重大度分布
   - 準拠率の算出
   - 優先的に対処すべき項目のリスト

## 📂 出力形式

### レビューレポート構成
```markdown
# C++14コードレビューレポート

## 📊 サマリー
- レビュー日時: [timestamp]
- レビュー範囲: [全体 or Git差分]
- 比較元コミット: [commit hash] (差分レビュー時のみ)
- 対象ファイル: [count]
- 変更行数: [added/modified/deleted lines] (差分レビュー時)
- 総行数: [lines]
- 検出問題数: [total issues]
  - Critical: [count]
  - High: [count]
  - Medium: [count]
  - Low: [count]

## 🚨 Critical Issues
### [ファイル名]:[行番号] - [ルールID]
**問題**: [説明]
**コード**:
```cpp
[問題のあるコード]
```
**修正案**:
```cpp
[修正後のコード]
```
**理由**: [詳細説明]

[繰り返し...]

## ⚠️ High/Medium/Low Issues
[同様の構成]

## ✅ 準拠状況
- AUTOSAR C++14準拠率: [percentage]
- CERT C++準拠率: [percentage]

## 📋 推奨アクション
1. [優先度1の修正項目]
2. [優先度2の修正項目]
3. [...]
```

## ✅ 成功基準

- [ ] すべての対象ファイルをレビュー完了
- [ ] AUTOSAR C++14の主要ルールをチェック済み
- [ ] CERT C++のセキュリティルールをチェック済み
- [ ] 重大度別に問題を分類
- [ ] 各問題に修正案を提供
- [ ] マークダウン形式のレポートを生成

## 💡 ヒント

- 大規模プロジェクトの場合は、モジュールごとに分割してレビュー
- 既存の静的解析ツール（Clang-Tidy、Cppcheck）の結果と併用すると効果的
- **プルリクエストレビュー**: コミットハッシュを指定して変更点のみレビュー
- **段階的レビュー**: 前回レビュー時のコミットから今回までの差分をレビュー
- レビュー結果について相談したい場合は @review-cpp14-code に質問してください

## 🔄 Git差分レビューの活用例

### プルリクエストのレビュー
```
#review-cpp14-code
対象: src/
コミット: a1b2c3d4  # PRのベースブランチのHEAD
```

### 前回レビューからの変更点
```
#review-cpp14-code
対象: src/core/
コミット: e5f6g7h8  # 前回レビュー時のコミット
```

### 特定のコミット間の変更
ターミナルで以下を確認:
```bash
git log --oneline -10  # 最近のコミットを確認
git diff <古いコミット>..HEAD --name-only  # 変更ファイル一覧
```
その後、コミットハッシュを指定してレビュー実行

## 🔗 参考資料

- [AUTOSAR C++14 Coding Guidelines](https://www.autosar.org/standards/adaptive-platform/adaptive-platform-1711/coding-guidelines-for-the-use-of-the-c14-language-in-critical-and-safety-related-systems/)
- [SEI CERT C++ Coding Standard](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682)
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
