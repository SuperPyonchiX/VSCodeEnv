---
description: 'リポジトリ用の高品質なプロンプトファイルを生成するプロンプト'
agent: 'agent'
---

# 高品質なプロンプトファイルの作成

あなたはコードエージェントです。あなたのタスクは、https://code.visualstudio.com/docs/copilot/customization/prompt-files の公式ガイダンスに従って、このリポジトリに完全で正確なプロンプトファイルを作成することです。

## プロンプトファイルとは?

プロンプトファイルは、GitHub Copilot Chat用の再利用可能なプロンプトを定義するMarkdownファイルです。これらのファイルは、一貫した高品質の結果を提供するために、予測可能な動作、明確な期待値、最小限の権限、リポジトリ間の移植性を持つように設計されています。

## 重要原則

- **再利用可能性**: 複数のプロジェクトやシナリオで使用できる汎用的なプロンプト
- **明確な期待値**: 入力、処理、出力を明確に定義
- **最小権限**: タスクに必要な最小限のツールのみを使用
- **予測可能性**: 一貫した結果を生成する構造化されたワークフロー
- **標準化された場所**: `.github/prompts/` ディレクトリに配置

## 必須フロントマター

すべてのプロンプトファイルには、以下のYAMLフロントマターが必要です:

```yaml
---
description: 'プロンプトの目的と結果の簡単な説明'
mode: 'ask' # または 'edit' または 'agent'
---
```

### フロントマターフィールド

| フィールド | 必須 | 説明 | 例 |
|-----------|------|------|-----|
| `description` | はい | シングルクォートで囲まれた簡潔な説明（実行可能な結果） | `'コードレビューチェックリストを生成'` |
| `mode` | はい | プロンプトモード: `ask`, `edit`, `agent` | `'agent'` |
| `tools` | いいえ | 必要なツールの最小セット（配列） | `['search', 'fetch']` |
| `model` | いいえ | 最適化されたAIモデル | `'Claude Sonnet 4'` |

### モードの説明

- **ask**: 質問に答えるだけで、コード変更は行わない（読み取り専用）
- **edit**: ファイルの編集、作成、変更を行う（書き込み権限）
- **agent**: 複雑なタスクを自律的に実行（最大権限）

## ファイル命名規則

- `.prompt.md` 拡張子を使用
- ケバブケース（ハイフン区切りの小文字）を使用
- アクションを伝える説明的な名前
- 例: `generate-readme.prompt.md`, `generate-test-suite.prompt.md`, `analyze-performance.prompt.md`
- 避ける: `prompt1.prompt.md`, `myPrompt.prompt.md`

## ファイル構造

### 1. タイトル

クイックピック検索で表示される明確な見出し:

```markdown
# 包括的なドキュメントの生成
```

### 2. ミッションまたは主要指示

プロンプトの目的を明確に定義:

```markdown
## ミッション

あなたのタスクは、プロジェクトの包括的なドキュメントを生成することです。ドキュメントには、セットアップ手順、API リファレンス、使用例、トラブルシューティングガイドが含まれます。
```

または:

```markdown
## 主要指示

このプロンプトは、既存のコードベースに基づいて完全なテストスイートを作成します。すべての公開関数、メソッド、コンポーネントのテストをカバーする必要があります。
```

### 3. 範囲と前提条件

プロンプトが適用される条件と範囲:

```markdown
## 範囲と前提条件

### 範囲
- プロジェクトルートのREADME.mdファイル
- docs/ディレクトリのすべてのMarkdownファイル
- package.jsonからのAPIエンドポイント情報

### 前提条件
- プロジェクトにpackage.jsonが存在すること
- 既存のコードベースが実行可能であること
- 必要な依存関係がインストール済みであること

### 対象外
- サードパーティライブラリの内部ドキュメント
- デプロイメント固有の設定
- 開発環境のセットアップ
```

### 4. 入力

必須入力とオプション入力を明確に定義:

```markdown
## 入力

### 必須入力
- `${file}`: ドキュメント化対象のメインファイルまたはディレクトリ
- `${input:projectName}`: プロジェクト名

### オプション入力
- `${input:includeExamples:yes}`: 使用例を含めるか（デフォルト: yes）
- `${input:apiVersion:v1}`: APIバージョン（デフォルト: v1）

### コンテキスト変数
- `${workspaceFolder}`: プロジェクトルートディレクトリ
- `${selection}`: 現在選択されているコード（該当する場合）

### フォールバック動作
必須入力が提供されない場合:
1. ユーザーに入力を要求
2. 未定義のままの場合は処理を停止
3. エラーメッセージを表示: "必須フィールド '${input:projectName}' が提供されていません"
```

### 5. ワークフロー（ステップバイステップ）

明確で実行可能なステップ:

```markdown
## ワークフロー

### フェーズ 1: 発見と分析
1. **プロジェクト構造のスキャン**
   - `${workspaceFolder}` 配下のすべてのソースファイルを特定
   - package.json、README.md、設定ファイルを読み取り
   - 主要なエントリーポイントとモジュールを特定

2. **依存関係の分析**
   - package.jsonから依存関係リストを抽出
   - 各依存関係の目的を特定
   - バージョン要件を文書化

### フェーズ 2: コンテンツ生成
3. **README.mdの生成**
   - プロジェクト概要セクションを作成
   - インストール手順を追加
   - 使用例を含める
   - APIリファレンスへのリンクを追加

4. **APIドキュメントの作成**
   - 公開関数とメソッドを文書化
   - パラメータと戻り値の型を説明
   - 各APIの使用例を提供

### フェーズ 3: 検証と改善
5. **検証**
   - すべてのリンクが有効であることを確認
   - コード例が構文的に正しいことを確認
   - ドキュメントの完全性をチェック

6. **フォーマット**
   - Markdownフォーマットを適用
   - 一貫した見出しレベルを使用
   - 適切なコードブロック構文を使用
```

### 6. 出力期待値

期待される結果を明確に定義:

```markdown
## 出力期待値

### 期待されるファイル
1. **README.md** (プロジェクトルート)
   - プロジェクト概要
   - インストール手順
   - クイックスタートガイド
   - ライセンス情報

2. **docs/api.md**
   - 完全なAPIリファレンス
   - すべての公開関数の説明
   - パラメータとレスポンスの例

3. **docs/examples.md**
   - 実用的な使用例
   - 一般的なユースケース
   - トラブルシューティングのヒント

### 出力フォーマット
- すべてのファイルはMarkdownフォーマット
- コードブロックには適切な言語識別子を使用
- 見出しは階層的に構造化（H1 → H2 → H3）
- リンクは相対パスを使用

### ファイル配置場所
- README.md: `${workspaceFolder}/README.md`
- APIドキュメント: `${workspaceFolder}/docs/api.md`
- 例: `${workspaceFolder}/docs/examples.md`

### 成功基準
- すべてのセクションが完全で空でない
- すべてのコード例が構文的に正しい
- すべての内部リンクが有効
- ドキュメントがプロジェクト構造と一致
```

### 7. 品質保証

検証とテスト手順:

```markdown
## 品質保証

### 手動検証
レビュアーは以下を確認する必要があります:
- [ ] README.mdにすべての必須セクションが含まれている
- [ ] APIドキュメントがすべての公開関数をカバーしている
- [ ] コード例が実行可能である
- [ ] リンクが切れていない
- [ ] フォーマットが一貫している

### 自動チェック
以下のコマンドを実行して検証:
```bash
# Markdownリンティング
npm run lint:md

# リンク切れチェック
npm run check-links

# コード例の検証
npm run validate-examples
```

### エラーハンドリング
エラーが発生した場合:
1. エラーの詳細を明確に報告
2. 問題の場所を特定（ファイル名と行番号）
3. 推奨される修正方法を提供
4. ユーザーに確認を求めてから再試行

## 入力とコンテキスト変数の使用

### 基本的な変数

```markdown
## 入力

### ユーザー入力変数
- `${input:variableName}`: ユーザーに入力を要求
- `${input:variableName:defaultValue}`: デフォルト値付き入力

### コンテキスト変数
- `${file}`: 現在のファイルパス
- `${selection}`: 選択されたテキスト
- `${workspaceFolder}`: ワークスペースルート

### 使用例
プロジェクト名: `${input:projectName:MyProject}`
ターゲットファイル: `${file}`
作業ディレクトリ: `${workspaceFolder}`
```

## ツールと権限

### ツールの指定

最小限の必要なツールのみを指定:

```yaml
---
description: 'プロジェクト構造を分析'
mode: 'ask'
tools: ['search', 'fetch']  # 読み取り専用ツール
---
```

```yaml
---
description: 'ドキュメントを生成して保存'
mode: 'edit'
tools: ['search', 'fetch', 'create', 'edit']  # 書き込み権限を含む
---
```

### 一般的なツールセット

| ツール | 用途 | モード |
|--------|------|--------|
| `search` | コードベース検索 | ask, edit, agent |
| `fetch` | ファイル読み取り | ask, edit, agent |
| `create` | 新規ファイル作成 | edit, agent |
| `edit` | ファイル編集 | edit, agent |
| `terminal` | コマンド実行 | agent |
| `githubRepo` | GitHubリポジトリアクセス | ask, edit, agent |

### 破壊的操作の警告

```markdown
## 重要な警告

このプロンプトは以下の破壊的操作を実行します:
- 既存のREADME.mdを上書き
- docs/ディレクトリ内にファイルを作成
- package.jsonを変更（バージョン情報を更新）

**確認手順**:
1. 変更前に既存ファイルのバックアップを推奨
2. 生成された内容をレビュー
3. 承認後にファイルに保存
```

## 例とテンプレート

### プロンプトファイルの完全な例

```markdown
---
description: 'テストスイートを生成してカバレッジを向上'
mode: 'agent'
tools: ['search', 'fetch', 'create', 'edit']
model: 'Claude Sonnet 4'
---

# 包括的なテストスイートの生成

## ミッション

あなたのタスクは、既存のコードベースに対して包括的なテストスイートを生成することです。すべての公開関数、メソッド、コンポーネントをカバーする必要があります。

## 範囲と前提条件

### 範囲
- `src/` ディレクトリ内のすべてのソースファイル
- 公開APIとエクスポートされた関数
- ユーザー向けコンポーネント

### 前提条件
- テストフレームワークがインストール済み（Jest、Vitest等）
- ソースコードが正常にビルド可能
- TypeScript型定義が利用可能

## 入力

### 必須
- `${workspaceFolder}`: プロジェクトルートディレクトリ

### オプション
- `${input:testFramework:jest}`: 使用するテストフレームワーク
- `${input:coverageThreshold:80}`: 目標カバレッジ（%）

## ワークフロー

### フェーズ 1: 分析
1. **ソースファイルのスキャン**
   - `src/` ディレクトリ内のすべての .ts/.js ファイルを特定
   - 公開関数とクラスを抽出
   - 既存のテストファイルを確認

2. **テストギャップの特定**
   - テストが不足している関数をリスト化
   - カバレッジレポートを分析
   - 優先順位を決定

### フェーズ 2: テスト生成
3. **ユニットテストの作成**
   - 各公開関数に対してテストを生成
   - 正常系と異常系の両方をカバー
   - エッジケースを含める

4. **統合テストの作成**
   - コンポーネント間の相互作用をテスト
   - API呼び出しをモック
   - データフローを検証

### フェーズ 3: 検証
5. **テストの実行**
   - すべてのテストを実行
   - カバレッジレポートを生成
   - 失敗したテストを修正

## 出力期待値

### 期待されるファイル
各ソースファイル `src/module.ts` に対して:
- テストファイル: `src/module.test.ts`

追加ファイル:
- `tests/integration/` 内の統合テスト
- `tests/e2e/` 内のE2Eテスト

### テスト構造
\`\`\`typescript
describe('モジュール名', () => {
  describe('関数名', () => {
    it('通常ケースを処理する', () => {
      // テスト実装
    });

    it('エッジケースを処理する', () => {
      // テスト実装
    });

    it('無効な入力でエラーを投げる', () => {
      // テスト実装
    });
  });
});
\`\`\`

### 成功基準
- 目標カバレッジに到達（デフォルト: 80%）
- すべてのテストが合格
- テスト実行時間が妥当（< 30秒）

## 品質保証

### 自動検証
\`\`\`bash
# テストを実行
npm test

# カバレッジレポートを生成
npm run test:coverage

# カバレッジが閾値を満たすことを確認
npm run test:coverage -- --threshold=80
\`\`\`

### 手動レビュー
- [ ] テストが読みやすく理解しやすい
- [ ] テストが独立している（依存関係なし）
- [ ] モックが適切に使用されている
- [ ] エッジケースがカバーされている
- [ ] テスト名が説明的である
```

## ベストプラクティス

### 記述スタイル

- **命令形を使用**: 「分析する」「生成する」「検証する」
- **明確で簡潔に**: 短い文、明確な指示
- **曖昧さを避ける**: 具体的で実行可能な指示
- **構造化**: 論理的な流れ（理由 → コンテキスト → 入力 → アクション → 出力 → 検証）

### 入力の処理

- **デフォルト値を提供**: `${input:name:defaultValue}`
- **フォールバック動作を定義**: 入力が欠落している場合の処理
- **必須入力を明示**: ユーザーに何が必要かを明確に伝える

### ツールの最小化

- **最小権限の原則**: 必要なツールのみを使用
- **読み取り専用優先**: 可能な限り `ask` モードを使用
- **破壊的操作に警告**: ファイル変更やコマンド実行について明示

### ワークフローの明確化

- **段階的に分割**: 大きなタスクを小さなステップに分割
- **順序を明示**: 実行順序を明確に指定
- **検証ポイントを含める**: 各フェーズ後に検証

## 避けるべきパターン

- **過度に汎用的**: 具体的なタスクに焦点を当てる
- **曖昧な指示**: 「なるべく」「適切に」などの表現を避ける
- **例の欠如**: 期待される出力の具体例を含める
- **検証手順の欠如**: 成功を確認する方法を提供
- **エラー処理の欠如**: 失敗シナリオを考慮

## メンテナンス

- **定期的なレビュー**: プロジェクトの変更に応じて更新
- **ツールリストの更新**: 新しいツールや非推奨のツールに対応
- **モデル要件の確認**: 最適なAIモデルを指定
- **ドキュメントリンクの検証**: 外部リンクが有効であることを確認

## テストとデバッグ

プロンプトを確定する前に:

1. **VS Codeでテスト**: `Chat: Run Prompt` コマンドで実行
2. **代表的なシナリオで検証**: 典型的なユースケースでテスト
3. **エッジケースを確認**: 予期しない入力や状況をテスト
4. **出力を検証**: 期待される結果が生成されることを確認

## 最終注記

プロンプトファイルは、GitHub Copilot Chatで一貫した高品質の結果を生成するための再利用可能なテンプレートです。これらのファイルは明確で、構造化され、保守可能であるべきです。目標は、ユーザーが追加のガイダンスをほとんど必要とせずに、複雑なタスクを効率的に実行できるようにすることです。

## 参考資料

- **Prompt Files Documentation**: https://code.visualstudio.com/docs/copilot/customization/prompt-files
- **Awesome Copilot Prompt Files**: https://github.com/github/awesome-copilot/tree/main/prompts
- **Tool Configuration**: https://code.visualstudio.com/docs/copilot/chat/chat-agent-mode#_agent-mode-tools

## タスク完了基準

プロンプトファイルを作成する際は、以下を確認してください:
- [ ] YAMLフロントマターが完全で正確である
- [ ] `mode` が適切に設定されている（ask/edit/agent）
- [ ] `tools` が最小限に制限されている
- [ ] すべてのセクションが論理的に整理されている
- [ ] 入力変数が明確に定義されている
- [ ] ワークフローがステップバイステップである
- [ ] 出力期待値が具体的である
- [ ] 品質保証手順が実行可能である
- [ ] ファイル名がケバブケースで説明的である
- [ ] 代表的なシナリオでテスト済みである
