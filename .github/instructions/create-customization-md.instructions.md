---
description: 'ユーザー目的から統合的なカスタマイゼーションファイル(プロンプト/インストラクション/エージェント)を生成する際のガイドライン'
applyTo: '**/*.prompt.md, **/*.instructions.md, **/*.agent.md'
---

# 統合カスタマイゼーションファイル生成ガイドライン

**重要**: このインストラクションは、プロンプトファイルとエージェントファイルの両方から参照される「真実の唯一の情報源(Single Source of Truth)」です。詳細なガイドライン、命名規則、品質基準はすべてこのファイルに集約されています。

## プロジェクトコンテキスト

- **対象読者**: カスタマイゼーションファイルを生成するAIエージェントとレビュー担当者
- **技術**: GitHub Copilot のカスタマイゼーション機能（プロンプトファイル、インストラクションファイル、エージェントファイル）
- **目的**: ユーザーの目的を理解し、それを最適に達成する統合的なカスタマイゼーションスイートを生成する
- **位置づけ**: プロンプトとエージェントが参照する権威あるガイドライン

## 一般的な指示

### 統合アプローチ

カスタマイゼーションファイルを生成する際は、以下の原則に従ってください:

- **相互補完性**: 3つのファイルが互いに補完し合う設計にする
- **一貫性**: 用語、コンセプト、スタイルを統一する
- **相互参照**: ファイル間で適切に相互参照する
- **役割分担**: 各ファイルタイプの特性を活かした役割分担
- **統合性**: 独立して機能しつつ、統合的に使用することでより強力な効果を発揮
- **重複回避**: 詳細ガイドラインはこのファイルに集約し、プロンプト/エージェントでは参照のみ

### 各ファイルタイプの役割

| ファイルタイプ | 主な役割 | 適用タイミング | 配置場所 | 内容の焦点 |
|--------------|---------|--------------|---------|-----------|
| **プロンプト** (.prompt.md) | 特定のタスク実行 | ユーザーが明示的に呼び出す | `.github/prompts/` | **実行手順のみ** (ガイドラインは参照) |
| **インストラクション** (.instructions.md) | 継続的なガイダンス | 特定のファイルタイプで自動適用 | `.github/instructions/` | **詳細ガイドライン集** |
| **エージェント** (.agent.md) | 専門知識の提供 | ユーザーがエージェントを選択 | `.github/agents/` | **対話的支援** (ガイドラインは参照) |

## ファイル生成のワークフロー

### フェーズ 1: 目的分析

ユーザーの目的を分析する際は、以下を明確にする:

1. **明示的な要件**: ユーザーが明確に述べた要件
2. **暗黙的なニーズ**: 要件から推測される隠れたニーズ
3. **技術スタック**: 対象となる言語、フレームワーク、ツール
4. **ユースケース**: 具体的な使用シナリオ
5. **制約条件**: 技術的・組織的な制約

### フェーズ 2: 戦略設計

各ファイルの役割と相互関係を設計:

```
ユーザー目的
    ↓
┌───────────────┬───────────────┬───────────────┐
│ プロンプト    │インストラクション│ エージェント   │
├───────────────┼───────────────┼───────────────┤
│ タスク実行    │ 継続的ガイド   │ 専門知識      │
│ 明示的呼出    │ 自動適用      │ 対話的支援    │
│ 具体的アクション│ ルールと規約   │ コンサルテーション│
└───────────────┴───────────────┴───────────────┘
```

### フェーズ 3: ファイル生成順序

**推奨生成順序**: プロンプト → インストラクション → エージェント

この順序により:
1. 具体的なタスク（プロンプト）を先に定義
2. そのタスクを支えるルール（インストラクション）を定義
3. 全体を統括する専門家（エージェント）を定義

## プロンプトファイル生成ガイドライン

### 命名規則

- **動詞で始める**: `create-`, `analyze-`, `refactor-`, `optimize-`
- **ケバブケース**: 小文字とハイフンのみ使用
- **説明的**: ファイル名からタスクが明確に理解できる

**良い例**:
```
create-api-tests.prompt.md
analyze-performance-bottlenecks.prompt.md
refactor-legacy-code.prompt.md
```

**悪い例**:
```
prompt1.prompt.md
myPrompt.prompt.md
task.prompt.md
```

### フロントマター要件

```yaml
---
description: '具体的なタスクの説明（シングルクォート必須）'
mode: '[descriptive-name]'
---
```

### 必須セクション

1. **タイトル (H1)**: クイックピック検索用
2. **ミッション**: タスクの明確な目的
3. **範囲と前提条件**: 適用範囲と前提
4. **入力**: 必須/オプション入力変数
5. **ワークフロー**: ステップバイステップの手順
6. **出力期待値**: 期待される結果
7. **品質保証**: 検証手順

### ワークフローの記述

ワークフローは以下の構造で記述:

```markdown
## ワークフロー

### フェーズ 1: [フェーズ名]
1. **[ステップ名]**
   - 具体的なアクション 1
   - 具体的なアクション 2
   - 期待される結果

2. **[次のステップ名]**
   - アクション
   - 検証方法

### フェーズ 2: [次のフェーズ]
...
```

## インストラクションファイル生成ガイドライン

### 命名規則

- **プロンプトと同じベース名**: 対応するプロンプトファイルと同じベース名を使用
- **ケバブケース**: 小文字とハイフンのみ
- **拡張子のみ変更**: `.prompt.md` → `.instructions.md`

**良い例** (プロンプトが `create-api-endpoints.prompt.md` の場合):
```
create-api-endpoints.instructions.md
analyze-performance-bottlenecks.instructions.md
refactor-legacy-code.instructions.md
```

### フロントマター要件

```yaml
---
description: 'インストラクションの目的（シングルクォート必須）'
applyTo: '**/*.ts, **/*.tsx' # 適用対象のglobパターン
---
```

### applyTo パターンの設計

| パターン | 適用対象 | 例 |
|---------|---------|-----|
| `**/*.{ext}` | 特定の拡張子 | `**/*.ts` (全TypeScriptファイル) |
| `**/*.{ext1,ext2}` | 複数の拡張子 | `**/*.tsx, **/*.jsx` (Reactコンポーネント) |
| `path/**/*.{ext}` | 特定ディレクトリ配下 | `src/**/*.py` (srcディレクトリのPython) |
| `**/test/**/*.{ext}` | 特定パターンのパス | `**/test/**/*.ts` (テストファイル) |

### 必須セクション

1. **タイトル (H1)**: インストラクションの概要
2. **一般的な指示**: 高レベルのガイドライン
3. **ベストプラクティス**: 推奨されるパターン
4. **コード標準**: 命名規則、フォーマット、スタイル
5. **一般的なパターン**: 頻繁に使用される実装パターン
6. **避けるべきパターン**: アンチパターン
7. **検証**: 検証コマンドとチェックリスト

### 良い例と悪い例の記述

コーディング規約を示す際は、必ず良い例と悪い例の両方を含める:

```markdown
### 良い例: 型安全な関数定義

\`\`\`typescript
interface User {
  id: string;
  name: string;
  email: string;
}

function getUser(id: string): Promise<User> {
  return userRepository.findById(id);
}
\`\`\`

### 悪い例: any型の使用

\`\`\`typescript
function getUser(id: any): any {
  // 型安全性が失われる
  return userRepository.findById(id);
}
\`\`\`

**理由**: `any` 型はTypeScriptの型安全性を無効化し、バグの原因となります。
```

## エージェントファイル生成ガイドライン

### 命名規則

- **プロンプトと同じベース名**: 対応するプロンプトファイルと同じベース名を使用
- **ケバブケース**: 小文字とハイフンのみ
- **拡張子のみ変更**: `.prompt.md` → `.agent.md`

**良い例** (プロンプトが `create-api-endpoints.prompt.md` の場合):
```
create-api-endpoints.agent.md
analyze-performance-bottlenecks.agent.md
refactor-legacy-code.agent.md
```

### フロントマター要件

```yaml
---
description: 'エージェントの役割と専門性（シングルクォート必須）'
tools: ['vscode', 'edit', 'execute', 'read', 'search', 'web', 'excel/*', 'fetch/*', 'agents', 'todo'] # エージェントが使用するツール
handoffs: # オプション: 他のエージェントへの遷移定義
  - label: '実装を開始'
    agent: 'implementation'
    prompt: '上記の計画を実装してください。'
    send: false
---
```

### handoffs フィールドの詳細

handoffsは、エージェント間のシームレスな遷移を可能にする機能です。チャット応答の完了後、次のステップとしてハンドオフボタンが表示され、ユーザーはワンクリックで関連するコンテキストを持って次のエージェントに移行できます。

#### handoffs の各フィールド

| フィールド | 必須 | 説明 | 例 |
|----------|------|------|-----|
| `label` | ✅ | ハンドオフボタンに表示されるテキスト | `'実装を開始'` |
| `agent` | ✅ | 遷移先のエージェント識別子（ファイル名から.agent.mdを除いたもの） | `'implementation'` |
| `prompt` | ✅ | 遷移先エージェントに送信するプロンプトテキスト | `'上記の計画を実装してください。'` |
| `send` | ❌ | プロンプトを自動送信するか（デフォルト: `false`） | `false` |

#### handoffs のユースケース

handoffsは、以下のような段階的なワークフローを構築する際に特に有効です:

1. **プランニング → 実装**
   - 計画エージェントで実装計画を生成
   - handoffボタンで実装エージェントに遷移
   - 計画の内容が自動的に引き継がれる

2. **実装 → レビュー**
   - 実装完了後、コードレビューエージェントに遷移
   - セキュリティや品質の問題をチェック

3. **失敗テスト生成 → テスト合格実装**
   - まず失敗するテストを生成（レビューしやすい）
   - handoffで実装エージェントに遷移
   - テストが合格するようにコードを実装

#### handoffs の設計原則

**DO: 推奨事項**
- ✅ **論理的なフロー**: 自然な作業の流れに沿った遷移を設計
- ✅ **明確なラベル**: 次のステップが一目でわかるボタンテキスト
- ✅ **send: false を推奨**: ユーザーがプロンプトを確認・編集できるようにする
- ✅ **コンテキストの継承**: 前のステップの情報を適切に引き継ぐプロンプト
- ✅ **役割の分離**: 各エージェントの責任範囲を明確に分ける

**DON'T: 避けるべき事項**
- ❌ **send: true の乱用**: ユーザーの確認なしに自動実行するのは避ける
- ❌ **循環参照**: エージェント間で無限ループを作らない
- ❌ **過度に長いチェーン**: 5ステップ以上の長いワークフローは避ける
- ❌ **曖昧なラベル**: 「次へ」「続ける」などの不明瞭なボタンテキスト

#### handoffs の実装例

**例1: 3段階のワークフロー**

```yaml
# planner.agent.md
---
description: '実装計画を生成'
tools: ['search', 'fetch']
handoffs:
  - label: '実装を開始'
    agent: 'implementation'
    prompt: 'この計画に基づいて実装してください。'
    send: false
---
```

```yaml
# implementation.agent.md
---
description: '計画に基づいて実装'
tools: ['search', 'fetch', 'edit', 'create']
handoffs:
  - label: 'コードレビューを依頼'
    agent: 'reviewer'
    prompt: '実装されたコードをレビューしてください。'
    send: false
---
```

```yaml
# reviewer.agent.md
---
description: 'セキュリティと品質をレビュー'
tools: ['search', 'fetch']
handoffs:
  - label: '改善を実装'
    agent: 'implementation'
    prompt: 'レビュー結果に基づいて改善してください。'
    send: false
---
```

**例2: テスト駆動開発ワークフロー**

```yaml
# test-writer.agent.md
---
description: '失敗するテストを生成'
tools: ['search', 'fetch', 'edit', 'create']
handoffs:
  - label: 'テストを合格させる'
    agent: 'implementation'
    prompt: '上記のテストが合格するように実装してください。'
    send: false
---
```

```yaml
# implementation.agent.md
---
description: 'テストを合格させる実装'
tools: ['search', 'fetch', 'edit', 'execute']
handoffs:
  - label: 'リファクタリング'
    agent: 'refactoring'
    prompt: 'テストが合格したので、コードをリファクタリングしてください。'
    send: false
  - label: '追加テストの作成'
    agent: 'test-writer'
    prompt: 'エッジケースをカバーする追加テストを作成してください。'
    send: false
---
```

#### handoffs と tools の連携

handoffsを設計する際は、各エージェントのtools設定も考慮します:

| エージェント | tools | handoffs先 | 理由 |
|------------|-------|-----------|------|
| **planner** | `['search', 'fetch']` | implementation | コード編集を防ぐ（読み取り専用） |
| **implementation** | `['edit', 'create', 'search']` | reviewer | コード編集が可能 |
| **reviewer** | `['search', 'fetch']` | implementation | レビューのみ（編集不可） |
| **tester** | `['edit', 'create', 'execute']` | implementation | テスト作成と実行 |

この設計により、各エージェントは必要最小限の権限のみを持ち、安全性と明確性が向上します。

### 必須セクション

1. **タイトル (H1)**: エージェント名とペルソナ
2. **ミッション**: エージェントの目的と役割
3. **範囲と前提条件**: 専門領域と制約
4. **能力と知識**: 何ができるか、何を知っているか
5. **ワークフロー**: タスク実行の手順
6. **出力期待値**: 提供する価値
7. **使用例**: 具体的なユースケース

### ペルソナの定義

エージェントのアイデンティティを明確に定義:

```markdown
# React パフォーマンス最適化エキスパート

あなたは、Reactアプリケーションのパフォーマンス最適化に特化した専門家です。
以下の領域で深い知識と経験を持っています:

- **レンダリング最適化**: useMemo, useCallback, React.memoの効果的な使用
- **バンドルサイズ削減**: コード分割、ツリーシェイキング、遅延ロード
- **状態管理最適化**: 不要な再レンダリングの削減
- **パフォーマンス計測**: React DevTools Profiler、Lighthouse、Web Vitals
```

## ファイル間の統合

### 相互参照の記述

各ファイルから他のファイルへの参照を含める:

**プロンプトファイルから**:
```markdown
## 参考資料

### 内部ガイドライン
- [TypeScript コーディング標準](../.github/instructions/typescript-standards.instructions.md)
- [TypeScript アーキテクト エージェント](../.github/agents/typescript-standards.agent.md)
```

**インストラクションファイルから**:
```markdown
## 関連リソース

- [API生成プロンプト](../.github/prompts/create-api-endpoints.prompt.md)
- [APIアーキテクトエージェント](../.github/agents/create-api-endpoints.agent.md)
```

**エージェントファイルから**:
```markdown
## 利用可能なツール

このエージェントは以下のプロンプトとインストラクションと連携します:

- #file:.github/prompts/create-api-endpoints.prompt.md
- #file:.github/instructions/create-api-endpoints.instructions.md
```

### 一貫した用語の使用

3つのファイル間で一貫した用語を使用:

| 概念 | 統一用語 | 避けるべき混在 |
|------|---------|--------------|
| RESTful API | RESTful API | REST API, Rest api, rest API |
| TypeScript | TypeScript | typescript, TS |
| パフォーマンス最適化 | パフォーマンス最適化 | 性能改善、速度向上 |

## 品質チェックリスト

### プロンプトファイル

- [ ] `description` フィールドがシングルクォートで囲まれている
- [ ] `tools` が必要最小限に制限されている
- [ ] ワークフローが明確でステップバイステップである
- [ ] 出力期待値が具体的である
- [ ] 品質保証セクションに検証手順がある
- [ ] ファイル名がケバブケースで動詞で始まる

### インストラクションファイル

- [ ] `description` フィールドがシングルクォートで囲まれている
- [ ] `applyTo` パターンが適切なglobパターンである
- [ ] ルールが具体的で実行可能である
- [ ] 良い例と悪い例の両方が含まれている
- [ ] チェックリストが実用的である
- [ ] 検証コマンドが記載されている
- [ ] ファイル名がケバブケースで技術名を含む

### エージェントファイル

- [ ] `description` フィールドがシングルクォートで囲まれている
- [ ] エージェントのペルソナが明確である
- [ ] 専門知識が適切に定義されている
- [ ] ワークフローが実用的である
- [ ] ツールセットが適切である（最小権限の原則）
- [ ] 使用例が具体的である
- [ ] ファイル名がケバブケースで役割を示す
- [ ] handoffsが設定されている場合、各フィールドが完全である
- [ ] handoffsのラベルが明確で説明的である
- [ ] handoffsの遷移先エージェントが適切である

### 統合チェック

- [ ] 3つのファイルが一貫した用語を使用している
- [ ] ファイル間の相互参照が有効である
- [ ] 各ファイルの役割が明確に分担されている
- [ ] 重複する内容がない
- [ ] ユーザーの目的を適切に達成できる設計である
- [ ] handoffsが論理的なワークフローを形成している（該当する場合）
- [ ] handoffsの遷移先エージェントが存在する（該当する場合）

## 実装例: API開発支援

### 1. プロンプトファイル: `create-api-endpoints.prompt.md`

```yaml
---
description: 'RESTful APIエンドポイントとハンドラーを生成'
mode: 'api-architect'
---
```

**役割**: 具体的なAPIコードを生成するタスク実行

### 2. インストラクションファイル: `create-api-endpoints.instructions.md`

```yaml
---
description: 'RESTful API設計とセキュリティのベストプラクティス'
applyTo: '**/api/**/*.ts, **/routes/**/*.ts'
---
```

**役割**: APIファイルを編集する際の継続的なガイダンス

### 3. エージェントファイル: `create-api-endpoints.agent.md`

```yaml
---
description: 'API設計とアーキテクチャの専門家エージェント'
tools: ['vscode', 'edit', 'execute', 'read', 'search', 'web', 'excel/*', 'fetch/*', 'agents', 'todo']
---
```

**役割**: API設計に関する専門的なアドバイスと支援

### ファイル間の連携

```
ユーザー: "ユーザー管理APIを作成したい"
    ↓
エージェント: API設計を提案
    ↓
プロンプト: APIコードを生成
    ↓
インストラクション: コード編集時に自動適用
```

## エラーハンドリング

### ユーザー目的が不明確な場合

以下の質問で詳細を収集:

1. **対象技術**: どのプログラミング言語やフレームワークを使用しますか?
2. **ユースケース**: 具体的にどのようなタスクを実行したいですか?
3. **制約条件**: 技術的または組織的な制約はありますか?
4. **既存リソース**: 既存のコードベースやドキュメントはありますか?

### ファイル命名の競合

同名のファイルが存在する場合の対処:

1. **ユーザーに通知**: 既存ファイルの存在を明示
2. **代替案を提案**: 
   - より具体的な名前（例: `create-rest-api.prompt.md` → `create-express-rest-api.prompt.md`）
   - バージョン番号の追加（例: `api-standards-v2.instructions.md`）
3. **更新の可否を確認**: 既存ファイルの更新を希望するか確認

## ベストプラクティス

### DO: 推奨事項

✅ **具体的な例を含める**: 抽象的な説明ではなく、実際のコード例を提供
✅ **段階的に構造化**: 大きなタスクを小さなステップに分割
✅ **検証可能にする**: 成功基準とテスト手順を明確に定義
✅ **コンテキストを提供**: なぜそのアプローチが推奨されるかを説明
✅ **ツールを最小化**: 必要最小限の権限のみを要求
✅ **相互参照する**: 関連ファイル間でリンクを張る
✅ **用語を統一する**: 3つのファイル間で一貫した用語を使用

### DON'T: 避けるべき事項

❌ **曖昧な指示**: "適切に", "なるべく" などの曖昧な表現を避ける
❌ **過度な汎用化**: あまりにも広範囲をカバーしようとしない
❌ **例の欠如**: コード例なしの抽象的な説明のみ
❌ **検証手順の欠如**: 成功を確認する方法がない
❌ **役割の重複**: 3つのファイル間で役割が重複する
❌ **用語の不統一**: ファイル間で異なる用語を使用する
❌ **相互参照の欠如**: 関連ファイルへのリンクがない

## メンテナンスとバージョン管理

### 定期的なレビュー

以下のタイミングでカスタマイゼーションファイルをレビュー:

- **技術スタックの更新**: フレームワークやライブラリのバージョンアップ時
- **ベストプラクティスの変化**: 業界標準やコミュニティのプラクティスが変化した時
- **フィードバック収集**: ユーザーからのフィードバックがあった時
- **四半期ごと**: 定期的な品質チェック

### バージョン管理

- **Gitで管理**: すべてのカスタマイゼーションファイルをバージョン管理
- **変更ログ**: 重要な変更は `CHANGELOG.md` に記録
- **破壊的変更**: 大きな変更は新しいバージョンとして作成

## 参考資料

### 公式ドキュメント
- [VS Code Prompt Files](https://code.visualstudio.com/docs/copilot/customization/prompt-files)
- [VS Code Custom Instructions](https://code.visualstudio.com/docs/copilot/customization/custom-instructions)
- [VS Code Custom Agents](https://code.visualstudio.com/docs/copilot/customization/custom-agents)

### コミュニティリソース
- [Awesome Copilot](https://github.com/github/awesome-copilot)
- [Prompt Engineering Guide](https://www.promptingguide.ai/)

### 内部ガイドライン
- [プロンプトファイルガイドライン](./../instructions/prompt.instructions.md)
- [Markdownガイドライン](./../instructions/markdown.instructions.md)
- [Copilot インストラクション](./../../copilot-instructions.md)
